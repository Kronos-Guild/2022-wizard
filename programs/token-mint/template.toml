# Token Mint Program Template Configuration
# 
# This file defines how the wizard assembles the program from base and extension files.
# Rust contributors: Edit the .rs files, update this config if adding new extensions.
#
# HOW INJECTIONS WORK:
# - Extensions declare what code to inject into base files
# - The extraction script programmatically inserts code at known locations:
#   - "modules" -> after the last `pub mod` line in lib.rs
#   - "imports" -> after the last `use` statement in instruction files  
#   - "body" -> before the final `Ok(())` in handler functions
#   - "accounts" -> before the closing `}` of Accounts structs
#   - "args" -> added to function signature and #[instruction] macro

[program]
id = "token-mint"
name = "Token Mint"
description = "Create Token-2022 mints with optional extensions like metadata, transfer fees, and more."
version = "0.1.0"

# Base files are always included - these are the "templates" that get modified
[base]
lib = "base/lib.rs"
instructions = [
    { id = "create_mint", file = "base/instructions/create_mint.rs" },
]
other = [
    "base/instructions/mod.rs",
    "base/state/mod.rs",
    "base/error.rs",
]

# =============================================================================
# EXTENSIONS
# =============================================================================
# Each extension can inject code into base files.
# Rust devs write the extension module, then declare injections here.

[extensions.metadata]
name = "Metadata"
description = "Store token name, symbol, and URI on-chain using Token-2022 metadata extension"
default = true
locked = true  # Cannot be disabled - always included
files = ["extensions/metadata/mod.rs"]

# Inject into lib.rs
[extensions.metadata.inject.lib]
modules = "pub mod metadata;"

# Inject into create_mint instruction
[extensions.metadata.inject.create_mint]
imports = "use crate::metadata;"
body = """
    // Initialize metadata extension
    metadata::validate_metadata(&name, &symbol)?;
    let _metadata = metadata::init_metadata(name.clone(), symbol.clone(), uri.clone())?;
    msg!("Metadata extension initialized");"""

# -----------------------------------------------------------------------------

[extensions.transfer-fee]
name = "Transfer Fee"
description = "Charge a percentage fee on every token transfer"
default = false
conflicts_with = ["non-transferable"]
files = [
    "extensions/transfer-fee/mod.rs",
    "extensions/transfer-fee/update_fee.rs",
]

# UI configuration for this extension
[extensions.transfer-fee.config]
fee_basis_points = { type = "number", name = "Fee (Basis Points)", description = "100 = 1%", default = 100, min = 0, max = 10000 }
max_fee = { type = "number", name = "Max Fee", description = "Maximum fee in token units", default = 1000000, min = 0 }

# Inject into lib.rs
[extensions.transfer-fee.inject.lib]
modules = "pub mod transfer_fee;"
# Add update_fee instruction to the program
instructions = """

    /// Updates the transfer fee configuration.
    /// Only the fee authority can call this.
    pub fn update_transfer_fee(
        ctx: Context<UpdateTransferFee>,
        fee_basis_points: u16,
        max_fee: u64,
    ) -> Result<()> {
        transfer_fee::update_fee::handler(ctx, fee_basis_points, max_fee)
    }"""

# Inject into create_mint instruction
[extensions.transfer-fee.inject.create_mint]
imports = "use crate::transfer_fee;"
args = ["fee_basis_points: u16", "max_fee: u64"]
body = """
    // Initialize transfer fee extension
    let _fee_config = transfer_fee::init_transfer_fee(fee_basis_points, max_fee)?;
    msg!("Transfer fee extension initialized: {} bps, max {}", fee_basis_points, max_fee);"""
accounts = """
    /// The fee authority that can update and collect fees
    pub fee_authority: Signer<'info>,"""

# -----------------------------------------------------------------------------

[extensions.close-mint]
name = "Close Mint"
description = "Allow the mint authority to close the mint and reclaim rent"
default = false
files = ["extensions/close-mint/mod.rs"]

# Inject into lib.rs  
[extensions.close-mint.inject.lib]
modules = "pub mod close_mint;"
instructions = """

    /// Closes the mint account and returns rent to the destination.
    /// Requires total supply to be 0.
    pub fn close_mint(ctx: Context<CloseMint>) -> Result<()> {
        close_mint::handler(ctx)
    }"""

# Inject into create_mint instruction
[extensions.close-mint.inject.create_mint]
imports = "use crate::close_mint;"
body = """
    // Close mint extension enabled - mint can be closed when supply is 0
    msg!("Close mint extension enabled");"""
accounts = """
    /// The close authority that can close the mint
    pub close_authority: Signer<'info>,"""

# -----------------------------------------------------------------------------

[extensions.non-transferable]
name = "Non-Transferable"
description = "Make tokens soulbound - they cannot be transferred after minting"
default = false
conflicts_with = ["transfer-fee"]
files = ["extensions/non-transferable/mod.rs"]

# Inject into lib.rs
[extensions.non-transferable.inject.lib]
modules = "pub mod non_transferable;"

# Inject into create_mint instruction
[extensions.non-transferable.inject.create_mint]
imports = "use crate::non_transferable;"
body = """
    // Initialize non-transferable (soulbound) extension
    let _config = non_transferable::init_non_transferable()?;
    msg!("Non-transferable extension initialized - tokens are soulbound");"""
